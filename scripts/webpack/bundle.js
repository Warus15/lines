/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is not neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./scripts/ts/Main.ts":
/*!****************************!*\
  !*** ./scripts/ts/Main.ts ***!
  \****************************/
/*! namespace exports */
/*! exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_require__, __webpack_require__.r, __webpack_exports__, __webpack_require__.* */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _classes_Game__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./classes/Game */ \"./scripts/ts/classes/Game.ts\");\n\r\nvar game = new _classes_Game__WEBPACK_IMPORTED_MODULE_0__.Game();\r\n\n\n//# sourceURL=webpack://kulki/./scripts/ts/Main.ts?");

/***/ }),

/***/ "./scripts/ts/Settings.ts":
/*!********************************!*\
  !*** ./scripts/ts/Settings.ts ***!
  \********************************/
/*! namespace exports */
/*! export Settings [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_require__.r, __webpack_exports__, __webpack_require__.d, __webpack_require__.* */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Settings\": () => /* binding */ Settings\n/* harmony export */ });\nvar Settings = /** @class */ (function () {\r\n    function Settings() {\r\n    }\r\n    //Methods\r\n    Settings.getRandomColor = function () {\r\n        var index = this.getRandomNumber(0, this.colors.length);\r\n        var color = this.colors[index];\r\n        return { color: color, colorID: index };\r\n    };\r\n    Settings.RandomNumber = function (min, max) {\r\n        return Math.floor(Math.random() * max + min);\r\n    };\r\n    Settings.getCoords = function (boardRepresentation) {\r\n        var coordsArray = new Array();\r\n        if (this.checkGameOver(boardRepresentation))\r\n            return { canPlace: false, coords: null };\r\n        for (var i = 0; i < 3; i++) {\r\n            var x = void 0;\r\n            var y = void 0;\r\n            do {\r\n                x = this.getRandomNumber(0, 9);\r\n                y = this.getRandomNumber(0, 9);\r\n            } while (boardRepresentation[y][x].occupied);\r\n            var coords = {\r\n                x: x,\r\n                y: y\r\n            };\r\n            boardRepresentation[y][x].occupied = true;\r\n            coordsArray.push(coords);\r\n        }\r\n        return { canPlace: true, coords: coordsArray };\r\n    };\r\n    Settings.checkGameOver = function (boardRepresentation) {\r\n        var possiblePlacesCounter = this.countPossiblePlaces(boardRepresentation);\r\n        if (possiblePlacesCounter <= 3)\r\n            return true;\r\n        else\r\n            return false;\r\n    };\r\n    Settings.countPossiblePlaces = function (boardRepresentation) {\r\n        var possiblePlacesCounter = 0;\r\n        for (var i = 0; i < this.BoardSize; i++)\r\n            for (var j = 0; j < boardRepresentation[i].length; j++) {\r\n                if (!boardRepresentation[i][j].occupied)\r\n                    possiblePlacesCounter++;\r\n            }\r\n        return possiblePlacesCounter;\r\n    };\r\n    Settings.changeTime = function (seconds) {\r\n        var minutes = 0;\r\n        while (seconds >= 60) {\r\n            minutes++;\r\n            seconds -= 60;\r\n        }\r\n        var time = { minutes: minutes, seconds: seconds };\r\n        return time;\r\n    };\r\n    Settings.getRandomQuote = function () {\r\n        return this.quotes[this.getRandomNumber(0, this.quotes.length)];\r\n    };\r\n    Settings.BoardSize = 9;\r\n    Settings.OrbsToPop = 5;\r\n    Settings.timeoutValue = 1500;\r\n    Settings.colors = [\r\n        \"red\",\r\n        \"blue\",\r\n        \"aquamarine\",\r\n        \"pink\",\r\n        \"purple\",\r\n        \"yellow\",\r\n        \"lime\"\r\n    ];\r\n    Settings.quoteDisplay = document.getElementById(\"quote\");\r\n    Settings.quotes = [\r\n        {\r\n            quote: \"Don't hate the player hate the game.\",\r\n            author: \"Ice T\"\r\n        },\r\n        {\r\n            quote: \"Better by far you should forget and smile, than that you should remember and be sad.\",\r\n            author: \"Christina Rossetti\"\r\n        },\r\n        {\r\n            quote: \"Of all sad words of tongue or pen, the saddest are these, 'It might have been.\",\r\n            author: \"John Greenleaf Whittier\"\r\n        },\r\n        {\r\n            quote: \"The pain I feel now is the happiness I had before. That's the deal.\",\r\n            author: \"C.S. Lewis\"\r\n        },\r\n        {\r\n            quote: \"This thing we call \\\"failure\\\" is not the falling down, but the staying down.\",\r\n            author: \"Mary Pickford\"\r\n        },\r\n        {\r\n            quote: \"Whenever I climb I am followed by a dog called Ego.\",\r\n            author: \"Friedrich Nietzsche\"\r\n        },\r\n        {\r\n            quote: \"In the end… We only regret the chances we didn’t take\",\r\n            author: \"Lewis Carroll\"\r\n        }\r\n    ];\r\n    Settings.getRandomNumber = Settings.RandomNumber;\r\n    Settings.convertTime = Settings.changeTime;\r\n    return Settings;\r\n}());\r\n\r\n\n\n//# sourceURL=webpack://kulki/./scripts/ts/Settings.ts?");

/***/ }),

/***/ "./scripts/ts/classes/Decorators.ts":
/*!******************************************!*\
  !*** ./scripts/ts/classes/Decorators.ts ***!
  \******************************************/
/*! namespace exports */
/*! export highlightCurrentTile [provided] [no usage info] [missing usage info prevents renaming] */
/*! export showMotivationQuote [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_require__, __webpack_require__.r, __webpack_exports__, __webpack_require__.d, __webpack_require__.* */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"showMotivationQuote\": () => /* binding */ showMotivationQuote,\n/* harmony export */   \"highlightCurrentTile\": () => /* binding */ highlightCurrentTile\n/* harmony export */ });\n/* harmony import */ var _Settings__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Settings */ \"./scripts/ts/Settings.ts\");\n\r\nfunction showMotivationQuote(a, b, c) {\r\n    var original = c.value;\r\n    c.value = function () {\r\n        var args = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            args[_i] = arguments[_i];\r\n        }\r\n        var result = original.apply(this, args);\r\n        var quote = _Settings__WEBPACK_IMPORTED_MODULE_0__.Settings.getRandomQuote();\r\n        _Settings__WEBPACK_IMPORTED_MODULE_0__.Settings.quoteDisplay.innerHTML = \"<i>\\\"\" + quote.quote + \"\\\" ~ \" + quote.author + \"</i>\";\r\n        return result;\r\n    };\r\n}\r\nfunction highlightCurrentTile(a, b, c) {\r\n    var original = c.value;\r\n    c.value = function () {\r\n        var args = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            args[_i] = arguments[_i];\r\n        }\r\n        var result = original.apply(this, args);\r\n        this.boardRepresentation[this.endNode.y][this.endNode.x].tile.div.className = \"currentTile\";\r\n        return result;\r\n    };\r\n}\r\n\n\n//# sourceURL=webpack://kulki/./scripts/ts/classes/Decorators.ts?");

/***/ }),

/***/ "./scripts/ts/classes/Game.ts":
/*!************************************!*\
  !*** ./scripts/ts/classes/Game.ts ***!
  \************************************/
/*! namespace exports */
/*! export Game [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_require__, __webpack_require__.r, __webpack_exports__, __webpack_require__.d, __webpack_require__.* */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Game\": () => /* binding */ Game\n/* harmony export */ });\n/* harmony import */ var _Tile__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Tile */ \"./scripts/ts/classes/Tile.ts\");\n/* harmony import */ var _Settings__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Settings */ \"./scripts/ts/Settings.ts\");\n/* harmony import */ var _Preview__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Preview */ \"./scripts/ts/classes/Preview.ts\");\n/* harmony import */ var _Orb__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Orb */ \"./scripts/ts/classes/Orb.ts\");\n/* harmony import */ var _PathFinder__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./PathFinder */ \"./scripts/ts/classes/PathFinder.ts\");\n/* harmony import */ var _Popper__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Popper */ \"./scripts/ts/classes/Popper.ts\");\n\r\n\r\n\r\n\r\n\r\n\r\nvar Game = /** @class */ (function () {\r\n    function Game() {\r\n        var _this = this;\r\n        this.gameField = document.getElementById(\"gameField\");\r\n        this.boardSize = _Settings__WEBPACK_IMPORTED_MODULE_1__.Settings.BoardSize;\r\n        this.boardRepresentation = new Array();\r\n        this.active = true;\r\n        this.timer = 0;\r\n        this.timerDisplay = document.getElementById(\"timer\");\r\n        this.GameOver = false;\r\n        this.checkGameOver = function () {\r\n            if (_Settings__WEBPACK_IMPORTED_MODULE_1__.Settings.checkGameOver(_this.boardRepresentation)) {\r\n                _this.GameOver = true;\r\n                clearInterval(_this.timerInterval);\r\n                var time = _Settings__WEBPACK_IMPORTED_MODULE_1__.Settings.convertTime(_this.timer);\r\n                var points = _this.Popper.getPoints();\r\n                window.alert(\"Game Over! You've scored \" + points + \" points! You've been playing for \" + time.minutes + \" minutes \" + time.seconds + \" seconds.\");\r\n                _this.preview.clearPreview();\r\n            }\r\n        };\r\n        this.getGameOver = function () {\r\n            return _this.GameOver;\r\n        };\r\n        this.prepareNextRound = function () {\r\n            _this.checkGameOver();\r\n            _this.getCoords();\r\n            if (!_this.GameOver) {\r\n                _this.placeOrbs();\r\n                _this.getNextOrbs();\r\n                _this.preview.setPreview(_this.nextOrbs);\r\n            }\r\n        };\r\n        this.getActive = function () {\r\n            return _this.active;\r\n        };\r\n        this.setActive = function (active) {\r\n            _this.active = active;\r\n        };\r\n        //Handling Orb Selection\r\n        this.hasSelectedOrb = function () {\r\n            if (_this.selectedOrb)\r\n                return true;\r\n            else\r\n                return false;\r\n        };\r\n        this.setCurrentOrb = function (orb, deselect) {\r\n            if (!deselect) {\r\n                _this.selectedOrb = orb;\r\n            }\r\n            else {\r\n                _this.selectedOrb = null;\r\n            }\r\n        };\r\n        this.getSelectedOrb = function () {\r\n            return _this.selectedOrb;\r\n        };\r\n        this.moveOrb = function (startCoords, endCoords) {\r\n            _this.updateOrbDestination(startCoords, endCoords);\r\n            _this.clearOrbStartingPosition(startCoords);\r\n            _this.selectedOrb.getDiv().className = \"orb\";\r\n            _this.selectedOrb.x = endCoords.x;\r\n            _this.selectedOrb.y = endCoords.y;\r\n            setTimeout(function () {\r\n                _this.Popper.checkPop(endCoords);\r\n            }, _Settings__WEBPACK_IMPORTED_MODULE_1__.Settings.timeoutValue);\r\n            _this.setCurrentOrb(null, true);\r\n        };\r\n        this.initiateGame();\r\n    }\r\n    Game.prototype.initiateGame = function () {\r\n        this.initializeBoardRepresentation();\r\n        this.PathFinder = new _PathFinder__WEBPACK_IMPORTED_MODULE_4__.PathFinder(this.boardRepresentation);\r\n        this.Popper = new _Popper__WEBPACK_IMPORTED_MODULE_5__.Popper(this.boardRepresentation);\r\n        this.getNextOrbs();\r\n        this.getCoords();\r\n        this.initializeGameField();\r\n        this.initializePreview();\r\n        this.initializeTimer();\r\n        this.placeOrbs();\r\n        this.getNextOrbs();\r\n        this.preview.setPreview(this.nextOrbs);\r\n    };\r\n    Game.prototype.initializeBoardRepresentation = function () {\r\n        for (var i = 0; i < this.boardSize; i++)\r\n            this.boardRepresentation[i] = [];\r\n        for (var i = 0; i < this.boardSize; i++)\r\n            for (var j = 0; j < this.boardSize; j++) {\r\n                this.boardRepresentation[i][j] = {\r\n                    occupied: false,\r\n                    colorID: null,\r\n                    tile: null,\r\n                    orb: null,\r\n                    position: {\r\n                        x: j,\r\n                        y: i\r\n                    }\r\n                };\r\n            }\r\n    };\r\n    Game.prototype.initializePreview = function () {\r\n        this.preview = new _Preview__WEBPACK_IMPORTED_MODULE_2__.Preview();\r\n    };\r\n    Game.prototype.initializeTimer = function () {\r\n        var _this = this;\r\n        this.timerInterval = setInterval(function () {\r\n            _this.timer++;\r\n            var time = _Settings__WEBPACK_IMPORTED_MODULE_1__.Settings.convertTime(_this.timer);\r\n            _this.timerDisplay.innerText = time.minutes + \" m \" + time.seconds + \" s\";\r\n        }, 1000);\r\n    };\r\n    Game.prototype.getCoords = function () {\r\n        if (!this.GameOver) {\r\n            var nextCoords = _Settings__WEBPACK_IMPORTED_MODULE_1__.Settings.getCoords(this.boardRepresentation);\r\n            this.currentsCoords = nextCoords.coords;\r\n        }\r\n    };\r\n    Game.prototype.getNextOrbs = function () {\r\n        var NextOrbs = new Array();\r\n        for (var i = 0; i < 3; i++) {\r\n            var colorData = _Settings__WEBPACK_IMPORTED_MODULE_1__.Settings.getRandomColor();\r\n            var orb = new _Orb__WEBPACK_IMPORTED_MODULE_3__.Orb(colorData.color, colorData.colorID, null, null, this.PathFinder, this.setCurrentOrb, this.hasSelectedOrb, this.getSelectedOrb, this.getActive, this.getGameOver);\r\n            NextOrbs.push(orb);\r\n        }\r\n        this.nextOrbs = NextOrbs;\r\n    };\r\n    Game.prototype.initializeGameField = function () {\r\n        for (var i = 0; i < this.boardSize; i++) {\r\n            var newRow = document.createElement(\"div\");\r\n            newRow.className = \"row\";\r\n            for (var j = 0; j < this.boardSize; j++) {\r\n                var tile = new _Tile__WEBPACK_IMPORTED_MODULE_0__.Tile(j, i, false, this.hasSelectedOrb, this.getSelectedOrb, this.moveOrb, this.setActive, this.prepareNextRound, this.PathFinder);\r\n                var squareFieldDiv = tile.getDiv();\r\n                newRow.appendChild(squareFieldDiv);\r\n                this.boardRepresentation[i][j].tile = tile;\r\n            }\r\n            this.gameField.appendChild(newRow);\r\n        }\r\n    };\r\n    Game.prototype.placeOrbs = function () {\r\n        var _this = this;\r\n        var _loop_1 = function (i) {\r\n            var x = this_1.currentsCoords[i].x;\r\n            var y = this_1.currentsCoords[i].y;\r\n            var currentTile = this_1.boardRepresentation[y][x].tile;\r\n            var orb = this_1.nextOrbs[i];\r\n            orb.setX(x);\r\n            orb.setY(y);\r\n            this_1.boardRepresentation[y][x].orb = orb;\r\n            this_1.boardRepresentation[y][x].colorID = orb.getColorID();\r\n            currentTile.setOrb(orb);\r\n            setTimeout(function () {\r\n                _this.Popper.checkPop({ x: x, y: y });\r\n            }, 500);\r\n        };\r\n        var this_1 = this;\r\n        for (var i = 0; i < this.currentsCoords.length; i++) {\r\n            _loop_1(i);\r\n        }\r\n        this.currentsCoords = null;\r\n        this.nextOrbs = null;\r\n    };\r\n    Game.prototype.updateOrbDestination = function (startCoords, endCoords) {\r\n        this.boardRepresentation[endCoords.y][endCoords.x].orb = this.boardRepresentation[startCoords.y][startCoords.x].orb;\r\n        this.boardRepresentation[endCoords.y][endCoords.x].colorID = this.boardRepresentation[startCoords.y][startCoords.x].colorID;\r\n        this.boardRepresentation[endCoords.y][endCoords.x].tile.setOrb(this.selectedOrb);\r\n        this.boardRepresentation[endCoords.y][endCoords.x].occupied = true;\r\n    };\r\n    Game.prototype.clearOrbStartingPosition = function (startCoords) {\r\n        this.boardRepresentation[startCoords.y][startCoords.x].orb = null;\r\n        this.boardRepresentation[startCoords.y][startCoords.x].colorID = null;\r\n        this.boardRepresentation[startCoords.y][startCoords.x].occupied = false;\r\n        this.boardRepresentation[startCoords.y][startCoords.x].tile.setOrb(null);\r\n    };\r\n    return Game;\r\n}());\r\n\r\n\n\n//# sourceURL=webpack://kulki/./scripts/ts/classes/Game.ts?");

/***/ }),

/***/ "./scripts/ts/classes/Orb.ts":
/*!***********************************!*\
  !*** ./scripts/ts/classes/Orb.ts ***!
  \***********************************/
/*! namespace exports */
/*! export Orb [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_require__.r, __webpack_exports__, __webpack_require__.d, __webpack_require__.* */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Orb\": () => /* binding */ Orb\n/* harmony export */ });\nvar Orb = /** @class */ (function () {\r\n    function Orb(color, colorID, x, y, pathFinder, setCurrentGameOrb, gameHasSelectedOrb, getSelectedOrb, getActive, checkGameOver) {\r\n        this.color = color;\r\n        this.colorID = colorID;\r\n        this.x = x;\r\n        this.y = y;\r\n        this.PathFinder = pathFinder;\r\n        this.setCurrentGameOrb = setCurrentGameOrb;\r\n        this.gameHasSelectedOrb = gameHasSelectedOrb;\r\n        this.getSelectedOrb = getSelectedOrb;\r\n        this.getActive = getActive;\r\n        this.checkGameOver = checkGameOver;\r\n        this.prepareDiv();\r\n        this.prepareListener();\r\n    }\r\n    Orb.prototype.prepareDiv = function () {\r\n        this.div = document.createElement(\"div\");\r\n        this.div.className = \"orb\";\r\n        this.div.style[\"backgroundColor\"] = this.color;\r\n    };\r\n    Orb.prototype.prepareListener = function () {\r\n        var _this = this;\r\n        this.div.addEventListener(\"click\", function (event) {\r\n            event.stopPropagation();\r\n            if (_this.getActive() && !_this.checkGameOver())\r\n                _this.checkSelection();\r\n        });\r\n    };\r\n    Orb.prototype.checkSelection = function () {\r\n        this.PathFinder.updateNodeArray();\r\n        if (!this.gameHasSelectedOrb()) {\r\n            //There's no selected orb\r\n            this.selectOrb();\r\n        }\r\n        else {\r\n            //There's selected orb'\r\n            var currentOrb = this.getSelectedOrb();\r\n            this.setCurrentGameOrb(null, true);\r\n            //Selected orb is the same as clicked orb\r\n            if (currentOrb.x == this.x && currentOrb.y == this.y)\r\n                this.deselectOrb();\r\n            else {\r\n                currentOrb.deselectOrb();\r\n                this.selectOrb();\r\n            }\r\n        }\r\n    };\r\n    Orb.prototype.selectOrb = function () {\r\n        this.div.className = \"selectedOrb\";\r\n        this.setCurrentGameOrb(this, false);\r\n    };\r\n    Orb.prototype.deselectOrb = function () {\r\n        this.div.className = \"orb\";\r\n    };\r\n    Orb.prototype.setX = function (x) {\r\n        this.x = x;\r\n    };\r\n    Orb.prototype.setY = function (y) {\r\n        this.y = y;\r\n    };\r\n    Orb.prototype.getColor = function () {\r\n        return this.color;\r\n    };\r\n    Orb.prototype.getColorID = function () {\r\n        return this.colorID;\r\n    };\r\n    Orb.prototype.getDiv = function () {\r\n        return this.div;\r\n    };\r\n    return Orb;\r\n}());\r\n\r\n\n\n//# sourceURL=webpack://kulki/./scripts/ts/classes/Orb.ts?");

/***/ }),

/***/ "./scripts/ts/classes/PathFinder.ts":
/*!******************************************!*\
  !*** ./scripts/ts/classes/PathFinder.ts ***!
  \******************************************/
/*! namespace exports */
/*! export PathFinder [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_require__, __webpack_require__.r, __webpack_exports__, __webpack_require__.d, __webpack_require__.* */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"PathFinder\": () => /* binding */ PathFinder\n/* harmony export */ });\n/* harmony import */ var _Decorators__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Decorators */ \"./scripts/ts/classes/Decorators.ts\");\n/* harmony import */ var _Settings__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Settings */ \"./scripts/ts/Settings.ts\");\nvar __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\n\r\n\r\nvar PathFinder = /** @class */ (function () {\r\n    function PathFinder(boardRepresentation) {\r\n        this.nodeArray = new Array();\r\n        this.active = false;\r\n        this.distanceFromStart = 0;\r\n        this.path = new Array();\r\n        this.boardRepresentation = boardRepresentation;\r\n        this.initiateNodeArray();\r\n    }\r\n    PathFinder.prototype.initiateNodeArray = function () {\r\n        for (var i = 0; i < _Settings__WEBPACK_IMPORTED_MODULE_1__.Settings.BoardSize; i++)\r\n            this.nodeArray[i] = [];\r\n        for (var i = 0; i < _Settings__WEBPACK_IMPORTED_MODULE_1__.Settings.BoardSize; i++)\r\n            for (var j = 0; j < _Settings__WEBPACK_IMPORTED_MODULE_1__.Settings.BoardSize; j++) {\r\n                if (!this.boardRepresentation[i][j].occupied) {\r\n                    var node = {\r\n                        x: j,\r\n                        y: i,\r\n                        path: null,\r\n                        distanceFromStart: 999,\r\n                        visited: false,\r\n                        type: \"NODE\"\r\n                    };\r\n                    this.nodeArray[i][j] = node;\r\n                }\r\n                else\r\n                    this.nodeArray[i][j] = null;\r\n            }\r\n    };\r\n    PathFinder.prototype.resetNodeArray = function () {\r\n        this.nodeArray = null;\r\n        this.nodeArray = new Array();\r\n    };\r\n    PathFinder.prototype.updateNodeArray = function () {\r\n        this.resetNodeArray();\r\n        this.initiateNodeArray();\r\n        // console.table(this.nodeArray);\r\n    };\r\n    PathFinder.prototype.findPath = function (startCoords, endCoords) {\r\n        if (this.nodeArray[endCoords.y][endCoords.x]) {\r\n            var startNode = {\r\n                x: startCoords.x,\r\n                y: startCoords.y,\r\n                path: null,\r\n                distanceFromStart: 999,\r\n                visited: false,\r\n                type: \"START\"\r\n            };\r\n            this.startNode = startNode;\r\n            this.nodeArray[startCoords.y][startCoords.x] = startNode;\r\n            this.endNode = this.nodeArray[endCoords.y][endCoords.x];\r\n            if (this.pathFound)\r\n                this.reset(false);\r\n            var currentCoords = {\r\n                x: this.startNode.x,\r\n                y: this.startNode.y\r\n            };\r\n            var previousCoords = {\r\n                x: this.startNode.x,\r\n                y: this.startNode.y\r\n            };\r\n            this.calculateNodeDistance(currentCoords, previousCoords, this.distanceFromStart);\r\n            if (this.endNode.path != null) {\r\n                this.pathFound = true;\r\n                this.getPath();\r\n                this.highlightPath();\r\n            }\r\n        }\r\n        else\r\n            this.reset(false);\r\n    };\r\n    PathFinder.prototype.calculateNodeDistance = function (currentCoords, previousCoords, distanceFromStart) {\r\n        var distance = distanceFromStart;\r\n        var x = currentCoords.x;\r\n        var y = currentCoords.y;\r\n        this.nodeArray[y][x].visited = true;\r\n        if (distance < this.nodeArray[y][x].distanceFromStart)\r\n            this.nodeArray[y][x].distanceFromStart = distance;\r\n        this.nodeArray[y][x].path = this.nodeArray[previousCoords.y][previousCoords.x];\r\n        distance++;\r\n        try {\r\n            if (!this.nodeArray[y - 1][x].visited ||\r\n                (this.nodeArray[y - 1][x].visited &&\r\n                    this.nodeArray[y - 1][x].distanceFromStart > distance))\r\n                this.calculateNodeDistance({ x: x, y: y - 1 }, { x: x, y: y }, distance);\r\n        }\r\n        catch (error) { }\r\n        try {\r\n            if (!this.nodeArray[y + 1][x].visited ||\r\n                (this.nodeArray[y + 1][x].visited &&\r\n                    this.nodeArray[y + 1][x].distanceFromStart > distance))\r\n                this.calculateNodeDistance({ x: x, y: y + 1 }, { x: x, y: y }, distance);\r\n        }\r\n        catch (error) { }\r\n        try {\r\n            if (!this.nodeArray[y][x - 1].visited ||\r\n                (this.nodeArray[y][x - 1].visited &&\r\n                    this.nodeArray[y][x - 1].distanceFromStart > distance))\r\n                this.calculateNodeDistance({ x: x - 1, y: y }, { x: x, y: y }, distance);\r\n        }\r\n        catch (error) { }\r\n        try {\r\n            if (!this.nodeArray[y][x + 1].visited ||\r\n                (this.nodeArray[y][x + 1].visited &&\r\n                    this.nodeArray[y][x + 1].distanceFromStart > distance))\r\n                this.calculateNodeDistance({ x: x + 1, y: y }, { x: x, y: y }, distance);\r\n        }\r\n        catch (error) { }\r\n    };\r\n    PathFinder.prototype.getPath = function () {\r\n        var previusNode = this.endNode;\r\n        do {\r\n            this.path.unshift(previusNode);\r\n            previusNode = previusNode.path;\r\n        } while (previusNode.type != \"START\");\r\n        this.path.unshift(this.nodeArray[this.startNode.y][this.startNode.x]);\r\n    };\r\n    PathFinder.prototype.highlightPath = function () {\r\n        var _this = this;\r\n        this.path.forEach(function (node) {\r\n            _this.boardRepresentation[node.y][node.x].tile.highlightTile();\r\n        });\r\n    };\r\n    PathFinder.prototype.markPath = function () {\r\n        var _this = this;\r\n        this.path.forEach(function (node) {\r\n            _this.boardRepresentation[node.y][node.x].tile.markPath();\r\n        });\r\n    };\r\n    PathFinder.prototype.reset = function (clicked) {\r\n        if (!clicked)\r\n            this.clearHighlight();\r\n        this.pathFound = false;\r\n        this.path = null;\r\n        this.path = new Array();\r\n    };\r\n    PathFinder.prototype.clearHighlight = function () {\r\n        var _this = this;\r\n        this.path.forEach(function (node) {\r\n            _this.boardRepresentation[node.y][node.x].tile.clearHighlight();\r\n        });\r\n    };\r\n    __decorate([\r\n        _Decorators__WEBPACK_IMPORTED_MODULE_0__.highlightCurrentTile\r\n    ], PathFinder.prototype, \"highlightPath\", null);\r\n    return PathFinder;\r\n}());\r\n\r\n\n\n//# sourceURL=webpack://kulki/./scripts/ts/classes/PathFinder.ts?");

/***/ }),

/***/ "./scripts/ts/classes/Popper.ts":
/*!**************************************!*\
  !*** ./scripts/ts/classes/Popper.ts ***!
  \**************************************/
/*! namespace exports */
/*! export Popper [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_require__, __webpack_require__.r, __webpack_exports__, __webpack_require__.d, __webpack_require__.* */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Popper\": () => /* binding */ Popper\n/* harmony export */ });\n/* harmony import */ var _Settings__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Settings */ \"./scripts/ts/Settings.ts\");\n\r\nvar Popper = /** @class */ (function () {\r\n    function Popper(boardRepresentation) {\r\n        this.OrbsToPopNumber = _Settings__WEBPACK_IMPORTED_MODULE_0__.Settings.OrbsToPop;\r\n        this.pointsDisplay = document.getElementById(\"points\");\r\n        this.points = 0;\r\n        this.boardRepresentation = boardRepresentation;\r\n        this.popped = false;\r\n        this.rowToPop = new Array();\r\n        this.columnToPop = new Array();\r\n        this.stDiagonalToPop = new Array();\r\n        this.ndDiagonalToPop = new Array();\r\n    }\r\n    Popper.prototype.checkPop = function (coords) {\r\n        this.startCoords = coords;\r\n        this.colorIDToPop = this.boardRepresentation[coords.y][coords.x].colorID;\r\n        this.findOrbsToPop();\r\n        this.preparePopOrbs();\r\n    };\r\n    Popper.prototype.findOrbsToPop = function () {\r\n        this.startRowSearching();\r\n        this.startColumnSearching();\r\n        this.startStDiagonalSearching();\r\n        this.startNdDiagonalSearching();\r\n    };\r\n    Popper.prototype.startRowSearching = function () {\r\n        this.findRowOrbs(this.startCoords, true);\r\n        this.findRowOrbs(this.startCoords, false);\r\n    };\r\n    Popper.prototype.startColumnSearching = function () {\r\n        this.findColumnOrbs(this.startCoords, true);\r\n        this.findColumnOrbs(this.startCoords, false);\r\n    };\r\n    Popper.prototype.startStDiagonalSearching = function () {\r\n        this.findStDiagonalOrbs(this.startCoords, true);\r\n        this.findStDiagonalOrbs(this.startCoords, false);\r\n    };\r\n    Popper.prototype.startNdDiagonalSearching = function () {\r\n        this.findNdDiagonalOrbs(this.startCoords, true);\r\n        this.findNdDiagonalOrbs(this.startCoords, false);\r\n    };\r\n    //Checking Directions\r\n    Popper.prototype.findRowOrbs = function (coords, left) {\r\n        try {\r\n            var currentCoords = void 0;\r\n            if (left) {\r\n                currentCoords = {\r\n                    x: coords.x - 1,\r\n                    y: coords.y\r\n                };\r\n                if (this.checkEqualOrbs(currentCoords, \"ROW\"))\r\n                    this.findRowOrbs(currentCoords, true);\r\n            }\r\n            else {\r\n                currentCoords = {\r\n                    x: coords.x + 1,\r\n                    y: coords.y\r\n                };\r\n                if (this.checkEqualOrbs(currentCoords, \"ROW\"))\r\n                    this.findRowOrbs(currentCoords, false);\r\n            }\r\n        }\r\n        catch (error) { }\r\n    };\r\n    Popper.prototype.findColumnOrbs = function (coords, top) {\r\n        try {\r\n            var currentCoords = void 0;\r\n            if (top) {\r\n                currentCoords = {\r\n                    x: coords.x,\r\n                    y: coords.y - 1\r\n                };\r\n                if (this.checkEqualOrbs(currentCoords, \"COLUMN\"))\r\n                    this.findColumnOrbs(currentCoords, true);\r\n            }\r\n            else {\r\n                currentCoords = {\r\n                    x: coords.x,\r\n                    y: coords.y + 1\r\n                };\r\n                if (this.checkEqualOrbs(currentCoords, \"COLUMN\"))\r\n                    this.findColumnOrbs(currentCoords, false);\r\n            }\r\n        }\r\n        catch (error) { }\r\n    };\r\n    Popper.prototype.findStDiagonalOrbs = function (coords, topLeft) {\r\n        try {\r\n            var currentCoords = void 0;\r\n            if (topLeft) {\r\n                currentCoords = {\r\n                    x: coords.x - 1,\r\n                    y: coords.y - 1\r\n                };\r\n                if (this.checkEqualOrbs(currentCoords, \"ST_DIAGONAL\"))\r\n                    this.findStDiagonalOrbs(currentCoords, true);\r\n            }\r\n            else {\r\n                currentCoords = {\r\n                    x: coords.x + 1,\r\n                    y: coords.y + 1\r\n                };\r\n                if (this.checkEqualOrbs(currentCoords, \"ST_DIAGONAL\"))\r\n                    this.findStDiagonalOrbs(currentCoords, false);\r\n            }\r\n        }\r\n        catch (error) { }\r\n    };\r\n    Popper.prototype.findNdDiagonalOrbs = function (coords, topRight) {\r\n        try {\r\n            var currentCoords = void 0;\r\n            if (topRight) {\r\n                currentCoords = {\r\n                    x: coords.x + 1,\r\n                    y: coords.y - 1\r\n                };\r\n                if (this.checkEqualOrbs(currentCoords, \"ND_DIAGONAL\"))\r\n                    this.findNdDiagonalOrbs(currentCoords, true);\r\n            }\r\n            else {\r\n                currentCoords = {\r\n                    x: coords.x - 1,\r\n                    y: coords.y + 1\r\n                };\r\n                if (this.checkEqualOrbs(currentCoords, \"ND_DIAGONAL\"))\r\n                    this.findNdDiagonalOrbs(currentCoords, false);\r\n            }\r\n        }\r\n        catch (error) { }\r\n    };\r\n    Popper.prototype.checkEqualOrbs = function (coords, direction) {\r\n        if (this.boardRepresentation[coords.y][coords.x].colorID ==\r\n            this.colorIDToPop) {\r\n            switch (direction) {\r\n                case \"ROW\":\r\n                    this.rowToPop.push(coords);\r\n                    break;\r\n                case \"COLUMN\":\r\n                    this.columnToPop.push(coords);\r\n                    break;\r\n                case \"ST_DIAGONAL\":\r\n                    this.stDiagonalToPop.push(coords);\r\n                    break;\r\n                case \"ND_DIAGONAL\":\r\n                    this.ndDiagonalToPop.push(coords);\r\n                    break;\r\n            }\r\n            return true;\r\n        }\r\n        else\r\n            return false;\r\n    };\r\n    Popper.prototype.preparePopOrbs = function () {\r\n        if (this.rowToPop.length >= this.OrbsToPopNumber - 1)\r\n            this.popOrbs(this.rowToPop);\r\n        if (this.columnToPop.length >= this.OrbsToPopNumber - 1)\r\n            this.popOrbs(this.columnToPop);\r\n        if (this.stDiagonalToPop.length >= this.OrbsToPopNumber - 1)\r\n            this.popOrbs(this.stDiagonalToPop);\r\n        if (this.ndDiagonalToPop.length >= this.OrbsToPopNumber - 1)\r\n            this.popOrbs(this.ndDiagonalToPop);\r\n        if (this.popped) {\r\n            this.popOrbs([this.startCoords]);\r\n        }\r\n        this.reset();\r\n    };\r\n    Popper.prototype.popOrbs = function (orbsToPop) {\r\n        var _this = this;\r\n        this.popped = true;\r\n        this.updatePoints(orbsToPop.length);\r\n        orbsToPop.forEach(function (orbCoords) {\r\n            _this.boardRepresentation[orbCoords.y][orbCoords.x].orb = null;\r\n            _this.boardRepresentation[orbCoords.y][orbCoords.x].colorID = null;\r\n            _this.boardRepresentation[orbCoords.y][orbCoords.x].occupied = false;\r\n            _this.boardRepresentation[orbCoords.y][orbCoords.x].tile.removeOrb();\r\n        });\r\n        //   console.log(this.boardRepresentation);\r\n    };\r\n    Popper.prototype.updatePoints = function (points) {\r\n        this.points += points;\r\n        this.pointsDisplay.innerHTML = \"\" + this.points;\r\n    };\r\n    Popper.prototype.getPoints = function () {\r\n        return this.points;\r\n    };\r\n    Popper.prototype.reset = function () {\r\n        this.rowToPop = null;\r\n        this.rowToPop = new Array();\r\n        this.columnToPop = null;\r\n        this.columnToPop = new Array();\r\n        this.stDiagonalToPop = null;\r\n        this.stDiagonalToPop = new Array();\r\n        this.ndDiagonalToPop = null;\r\n        this.ndDiagonalToPop = new Array();\r\n        this.popped = false;\r\n    };\r\n    return Popper;\r\n}());\r\n\r\n\n\n//# sourceURL=webpack://kulki/./scripts/ts/classes/Popper.ts?");

/***/ }),

/***/ "./scripts/ts/classes/Preview.ts":
/*!***************************************!*\
  !*** ./scripts/ts/classes/Preview.ts ***!
  \***************************************/
/*! namespace exports */
/*! export Preview [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_require__, __webpack_require__.r, __webpack_exports__, __webpack_require__.d, __webpack_require__.* */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Preview\": () => /* binding */ Preview\n/* harmony export */ });\n/* harmony import */ var _Tile__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Tile */ \"./scripts/ts/classes/Tile.ts\");\n\r\nvar Preview = /** @class */ (function () {\r\n    function Preview() {\r\n        this.previewTilesDiv = document.getElementById(\"tilesPreview\");\r\n        this.initiateTilesPreview();\r\n    }\r\n    Preview.prototype.initiateTilesPreview = function () {\r\n        this.previewTiles = new Array();\r\n        for (var i = 0; i < 3; i++) {\r\n            var previewTile = new _Tile__WEBPACK_IMPORTED_MODULE_0__.Tile(null, null, true, null, null, null, null, null, null);\r\n            this.previewTiles.push(previewTile);\r\n            this.previewTilesDiv.appendChild(previewTile.getDiv());\r\n        }\r\n    };\r\n    Preview.prototype.setPreview = function (orbs) {\r\n        var _this = this;\r\n        orbs.forEach(function (orb, index) {\r\n            _this.previewTiles[index].setOrb(orb);\r\n        });\r\n    };\r\n    Preview.prototype.clearPreview = function () {\r\n        this.previewTiles.forEach(function (tile) {\r\n            tile.removeOrb();\r\n        });\r\n    };\r\n    return Preview;\r\n}());\r\n\r\n\n\n//# sourceURL=webpack://kulki/./scripts/ts/classes/Preview.ts?");

/***/ }),

/***/ "./scripts/ts/classes/Tile.ts":
/*!************************************!*\
  !*** ./scripts/ts/classes/Tile.ts ***!
  \************************************/
/*! namespace exports */
/*! export Tile [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_require__, __webpack_require__.r, __webpack_exports__, __webpack_require__.d, __webpack_require__.* */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Tile\": () => /* binding */ Tile\n/* harmony export */ });\n/* harmony import */ var _Settings__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Settings */ \"./scripts/ts/Settings.ts\");\n/* harmony import */ var _Decorators__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Decorators */ \"./scripts/ts/classes/Decorators.ts\");\nvar __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\n\r\n\r\nvar Tile = /** @class */ (function () {\r\n    function Tile(x, y, previewTile, gameHasSelectedOrb, getSelectedOrb, moveOrb, setActive, prepareNextRound, pathFinder) {\r\n        this.div = document.createElement(\"div\");\r\n        this.div.className = \"tile\";\r\n        this.orb = null;\r\n        this.orbDiv = null;\r\n        this.previewTile = previewTile;\r\n        this.x = x;\r\n        this.y = y;\r\n        this.gameHasSelectedOrb = gameHasSelectedOrb;\r\n        this.getSelectedOrb = getSelectedOrb;\r\n        this.moveOrb = moveOrb;\r\n        this.setActive = setActive;\r\n        this.prepareNextRound = prepareNextRound;\r\n        this.PathFinder = pathFinder;\r\n        if (!this.previewTile)\r\n            this.prepareListeners();\r\n    }\r\n    Tile.prototype.prepareListeners = function () {\r\n        var _this = this;\r\n        this.div.addEventListener(\"mouseover\", function (event) {\r\n            if (_this.gameHasSelectedOrb())\r\n                _this.mouseOverFunction();\r\n        });\r\n        this.div.addEventListener(\"click\", function (event) {\r\n            if (_this.gameHasSelectedOrb())\r\n                _this.clickFunction();\r\n        });\r\n    };\r\n    Tile.prototype.mouseOverFunction = function () {\r\n        var selectedOrb = this.getSelectedOrb();\r\n        var startCoords = {\r\n            x: selectedOrb.x,\r\n            y: selectedOrb.y\r\n        };\r\n        var endCoords = {\r\n            x: this.x,\r\n            y: this.y\r\n        };\r\n        if (!(startCoords.x == endCoords.x && startCoords.y == endCoords.y))\r\n            this.PathFinder.findPath(startCoords, endCoords);\r\n        else\r\n            this.PathFinder.reset(false);\r\n    };\r\n    Tile.prototype.clickFunction = function () {\r\n        var _this = this;\r\n        if (this.PathFinder.pathFound) {\r\n            var selectedOrb = this.getSelectedOrb();\r\n            var startCoords = {\r\n                x: selectedOrb.x,\r\n                y: selectedOrb.y\r\n            };\r\n            var endCoords = {\r\n                x: this.x,\r\n                y: this.y\r\n            };\r\n            this.moveOrb(startCoords, endCoords);\r\n            this.PathFinder.markPath();\r\n            this.PathFinder.reset(true);\r\n            this.setActive(false);\r\n            this.PathFinder.updateNodeArray();\r\n            setTimeout(function () {\r\n                _this.prepareNextRound();\r\n                _this.setActive(true);\r\n            }, _Settings__WEBPACK_IMPORTED_MODULE_0__.Settings.timeoutValue);\r\n        }\r\n        else {\r\n        }\r\n    };\r\n    Tile.prototype.getDiv = function () {\r\n        return this.div;\r\n    };\r\n    Tile.prototype.hasOrb = function () {\r\n        if (!this.orb)\r\n            return false;\r\n        else\r\n            return true;\r\n    };\r\n    Tile.prototype.setOrb = function (orb) {\r\n        this.orb = orb;\r\n        if (this.orb) {\r\n            this.orbDiv = this.orb.getDiv();\r\n            this.div.appendChild(this.orbDiv);\r\n        }\r\n    };\r\n    Tile.prototype.removeOrb = function () {\r\n        if (this.hasOrb()) {\r\n            this.div.removeChild(this.orbDiv);\r\n            this.orb = null;\r\n            this.orbDiv = null;\r\n        }\r\n    };\r\n    Tile.prototype.highlightTile = function () {\r\n        this.div.className = \"highlightedTile\";\r\n    };\r\n    Tile.prototype.clearHighlight = function () {\r\n        this.div.className = \"tile\";\r\n    };\r\n    Tile.prototype.markPath = function () {\r\n        var _this = this;\r\n        this.div.className = \"pathTile\";\r\n        setTimeout(function () {\r\n            _this.clearHighlight();\r\n        }, _Settings__WEBPACK_IMPORTED_MODULE_0__.Settings.timeoutValue);\r\n    };\r\n    __decorate([\r\n        _Decorators__WEBPACK_IMPORTED_MODULE_1__.showMotivationQuote\r\n    ], Tile.prototype, \"clickFunction\", null);\r\n    return Tile;\r\n}());\r\n\r\n\n\n//# sourceURL=webpack://kulki/./scripts/ts/classes/Tile.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		if(__webpack_module_cache__[moduleId]) {
/******/ 			return __webpack_module_cache__[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop)
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	// startup
/******/ 	// Load entry module
/******/ 	__webpack_require__("./scripts/ts/Main.ts");
/******/ 	// This entry module used 'exports' so it can't be inlined
/******/ })()
;